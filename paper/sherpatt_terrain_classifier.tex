\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{authblk}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{todonotes}
\usepackage{placeins}   % helps to keeps figures at the same page or within the /FloatBarrier
\usepackage{caption}    % lets you define the fontsize of figure captions
\usepackage{subcaption}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

%added by LK
\usepackage{textgreek}
\usepackage{ltablex} %have centerised tables
%\usepackage{subfig}

\renewcommand\Authfont{\fontsize{9}{10}\selectfont}
\renewcommand\Affilfont{\fontsize{8}{9}\itshape}

\title{Implementation of an On-Board Terrain Classifier based on Proprioceptive Sensor Data for a Planetary Rover}
\author[1]{Raul Dominguez}
\author[2]{Lennart Kuhr}
\author[1]{Jonathan Babel}
\author[1]{Florian Cordes}
\author[3]{Giulio Reina}
\author[1,4]{Frank Kirchner}
\affil[1]{DFKI Robotics Innovation Center Bremen Robert-Hooke-Str. 1, 28359 Bremen, Germany, \newline E-mail: name.surname@dfki.de}
\affil[2]{Institute of Space Systems, TU Braunschweig, Herman-Blenck-Stra√üe 23, 38108 Braunschweig, Germany, \newline E-mail: l.kuhr@tu-braunschweig.de}
\affil[3]{Department of Mechanics, Mathematics and Management, Polytechnic of Bari, Via Orabona 4, 70125, Bari, Italy, E-mail: giulio.reina@poliba.it}
\affil[4]{Robotics Research Group, University of Bremen, Germany}

\begin{document}

\date{}
\maketitle
\captionsetup[figure]{font=footnotesize}

\begin{abstract}
The implementation of a Support Vector Machine-Based terrain classifier for the hybrid wheeled-leg rover SherpaTT is presented in this paper. 
The first phase of classification consists of deriving the physical characteristics of the traversed terrain statistically from proprioceptive data (i.e. engineered features).
The features are then used by the classifier to distinguish between three different surface types: \emph{sand}, \emph{compact sand} and \emph{concrete}. 
Based on previous offline studies \cite{Dimastrogiovanni2020} the terrain classifier has been integrated into the control architecture of the rover, as well as deployed and tested in analog environment. 
The software runs completely on the onboard computer (OBC) of SherpaTT, embedded within the Robotics Construction Toolkit (Rock)\footnote{Rock: The Robot Construction Kit (\url{http://rock-robotics.org})} framework.
Insights on the implementation and the software architecture surrounding the classifier are provided. 
Performance metrics demonstrate that the terrain classifier can run on the OBC alongside with the rest of the control architecture, achieving an overall high accuracy in terrain classification.
\end{abstract}

%\todo[inline]{We have to limit the paper to 9 Pages}

\section{Introduction}

% Introduction main motivation and main idea of the paper explain in detail the implementation of a SMV-based proprioceptive terrain classifier
Planetary explorations missions are so far dominated by wheeled rover designs like Curiosity
or Perseverance \cite{moeller2021, welch2013}. Although wheeled locomotion is most energy-efficient
over flat terrain, it compromises drawbacks when exposed to demanding unstructured
terrain. Especially in unstructured environments with steep, sandy slopes and boulders
patches, wheeled systems reach their limitations \cite{kolvenbach2021}. In the past, several high slip and
excessive sinkage events have been encountered with exploration rovers, which have severely
disrupted mission timelines \cite{gonzalez2018}. It took five weeks to free the Opportunity
rover from sand in 2006 \cite{young2006} and rover trajectories need to be frequently adjusted to avoid
challenging terrain \cite{arvidson2017}. The potentially worst situation occurred in 2009, when the
Spirit rover got stuck in sand and was unable to recover, ultimately ending the mission
\cite{webster2009}. 
Terrain awareness, the correct modelling of transited surfaces and its classification is a key factor for reliable autonomous navigation. 
Surface modelling can be used for navigation in order to avoid operation problems like the ones previously described. 
Moreover, terrain awareness may enhance navigation capabilities, if drive settings are adapted in accordance to the 
terrain properties.
In this publication we introduce a software component capable of classifying three different terrain types based on the proprioceptive sensor data of SherpaTT. 
The component uses a Support Vector Machine (SVM) algorithm \cite{vapnik1992,cristianini2000} in its core. It is integrated into the software control architecture of the mobile exploration robot SherpaTT embedded into the Robotics Construction Toolkit (Rock) framework, such that it can be executed sufficiently fast during navigation. The terrain classifier uses force torque sensors, joint data and body acceleration estimates to classify the surface into one of three terrain types: \emph{sand, compact sand} and \emph{concrete}.
The three types represent distinct classes of surfaces characterized by its deformability and friction properties. In order to achieve a better classification performance as well as a more in-depth characterization of the surface patches, a feature calculation process is performed previous to the classification. 
%\todo[inline]{RD: Some small state of the art here would be interesting presenting what others have done, not long but at least presenting some similar works}

%Moreover, the classification performance achieved onboard SherpaTT was identified during tests on terrain that represent at least one of the three terrain type classes.

\section{Background}

% NOTE: This text is just a short introduction of what is coming in the next 3 subsections, if it is too repetitive we can remove it.

\subsection{SherpaTT}
\todo[inline]{RD: TODO for @JB description of SherpaTT and the software that is involved in the control and perception. Particularly that what is needed to provide the inputs that the terrain classifier uses}

SherpaTT is a hybrid wheeled-leg rover with an actively articulated suspension system. Its locomotion control system provides the basis for advanced locomotive capabilities with the ability to adapt to different terrain types \cite{cordes2018}. The rover is designed for operation in unstructured environments. It features terrain adaption based on force torque sensors inputs, trajectory control and path planning as well as environment reconstruction through data fusion of extereoceptive and proprioceptive data.

\begin{figure}[!htb]
    \begin{subfigure}[t]{0.44\textwidth}
        \includegraphics[width=\textwidth]{../figures/terrain_classifier_sensor_inputs.png}
        \caption{\label{fig:SensorInputs}Sensor and joint inputs to the Terrain Classifier}
    \end{subfigure}
    \begin{subfigure}[t]{0.55\textwidth}
        \includegraphics[width=\textwidth]{../figures/MCS-Structure.pdf}
        \caption{\label{fig:MCS}Motion Control System of SherpaTT \cite{cordes_phd_2018}}
    \end{subfigure}
     \caption{\label{fig:Loco}(a) Input features for the terrain classifier originate from the following actuators (1)-(5) and sensors (6)-(7) on SherpaTT: (1) wheel drive, (2) wheel steering, (3) linear knee, (4) linear shoulder, (5) pan shoulder, (6) IMU, (7) Force-Torque. (b) Simplified layout of the Motion Control System of SherpaTT. Source: F. Cordes.}
\end{figure}


\subsection{Development Tools}

The software enabling the control and perception mechanisms of SherpaTT, exchanges data and information through the Robotics Construction Toolkit (Rock) framework. Rock offers a set of useful tools for the development, testing and evaluation of the software libraries (e.g. runtime data exchange statistics and visualization). In particular, tools for data logging, replaying and memory-signature based data selection from data streams have been employed in this implementation. The framework not only provides wrapping mechanisms for the libraries and its communications, but also the possibility to enforce realtime execution of the control loops when using a realtime supporting Linux kernel. 

% Challenges
Data selection at runtime is on of the key features addressed by the middleware. 
The problem consists in generating matrices of synchronous sample values for classification online from data streams with multiple frequencies.
Each data stream relevant for the classification contains in addition to the relevant data, data which has to be filtered out (e.g. timestamps) since it is irrelevant for the classification.
The library \emph{type to vector}\footnote{Type to vector: \url{https://github.com/rock-data-processing/data_processing-orogen-type_to_vector}} is used
to select the fields of the datatypes in the samples of the data stream t. It uses memory type descriptions of the samples, which contain relevant data to select from the incoming streams only the relevant attributes and stack them into the input matrix. 

The synchronicity of the data is achieved by labeling sensor data with timestamps at acquisition time.
Data streams can have different update rates, but the input matrices need data from multiple sources at the same rate, therefore a strategy is needed to drop or interpolate data. 

The Rock logging mechanism is used to fuse data streams and store sensor data on the hard drive, while preserving it for later offline use (i.e. data collection). 
Two further tools are employed to process the logged data offline: rock-replay for testing the runtime functionality on the development environment and \emph{pocolog to msgpack}\footnote{Pocolog to Msgpack: \url{https://github.com/rock-core/tools-pocolog2msgpack}} to select and prepare the data, so that it can be employed for training and testing the classifier.
\emph{pocolog to msgpack} converts data from its rock binary representation to the almost universal \emph{msgpack} format.
Moreover, \emph{pocolog to msgpack} allows for the conversion of logged data into python data frames, the widely used python data science and machine learning format. 
Finally, the runtime inspection tools of Rock were utilized to monitor the processing time of the classifier, the connections between separate software components and to visualize the coherence of all input data streams. 


\subsection{Terrain Classifier}
\todo[inline]{RD: for @RD Review this section}
% Background and approach

The supervised machine learning algorithm Support Vector Machine (SVM) is utilized in order to classify three terrain types based on sensor data. The presented terrain classifier therefore represents an applied SVM. Applying such an algorithm requires to first train a SVM classification model, which is later on used to classify an n-dimensional datapoint.
The model's dimensions are called features. In order to achieve maximum separation between the data classes the optimal features need to be identified. As a result, the feature selection process allows to identify the most critical set of input data to the classifier. 
%features differs in performance  
%feature selection

\subsubsection{Model Training}
Generally SVMs aim to separate data of multiple classes. In geometrical terms it divides the data with a n-dimensional hyperplane, the so called decision boundary. The hyperplane parameter, also referred to as weights, are iteratively optimized to allow the largest distance between the hyperplane and the nearest datapoints, which eventually are the support vectors.  
By changing the dot-product calculation, which is also known as the kernel trick, within the underlying geometrical condition, various correlations of the data's dimensions can be recognized. Correlation can be obtained through polynomial or Gaussian radial based functions or simply via linear correlation.
The generated set of weights is referred to as classification model and the generation process is referred to as training.\cite{kuhr2021}
%OvA multiclass strategy

\subsubsection{Model Testing}
Before applying the model, its' classification performance needs to be measured using labeled data. This testing process obtains performance measures, which can be visualized within confusion matrices. A description of a three class confusion matrix is depicted in Figure~\ref{fig:CMdescrpit}.\cite{kuhr2021}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{../figures/CM_Description.pdf}
\caption{\label{fig:CMdescrpit}Description of the applied three class confusion matrix to visualize the performance measures: precision, recall and accuracy.\cite{kuhr2021}}
\end{figure}
\begin{itemize}
\item Accuracy: The ratio of correct classified samples out of all tested samples. 

$\frac{T\textsubscript{overall}}{(T+F)\textsubscript{overall}}$

\item Recall : The ratio of correct classified samples out of all samples that belong to the same class.

$\frac{T\textsubscript{class}}{(T+F)\textsubscript{actual class}}$

\item Precision: The ratio of all correct classifications that the classifier assigns to one class.

$\frac{T\textsubscript{class}}{(T+F)\textsubscript{predicted class}}$

\end{itemize}

\subsubsection{Feature Selection}
For computational reasons and simplicity, it is desired to reduce the model's dimensionality by selecting the most critical features for the  classification task. A large set of statistical moments of the features is considered within the selection process. The features represent direct sensor parameter as well as physical parameter such as mechanical and electrical power, friction coefficients and wheel speed deviations of each wheel in relation to the others. The hereby used sensor parameter are listed in Table~\ref{fig:features1}. In this case, the statistical moments mean, variance, skewness and kurtosis are calculated. In order to reduce the dimensionality of inputs to the classifier, the most critical features for terrain classification are identified by using the WB index and the Pearson Coefficient as detailed in \cite{Dimastrogiovanni2020}. 
The list of selected features alongside with the used statistical moment is shown in Table~\ref{fig:optiF}. 

\begin{table}[h!]
   \centering
    \caption{Acquired physical proprioceptive data from datastreams: MCS Logger (MCS), Joint Deployment Logger (JDL), Sensors Deployment Logger (SDL). The forces and torques are within the Body Coordinate System (BCS).\cite{Dimastrogiovanni2020}\label{fig:features1}}
    \begin{tabularx}{\columnwidth}{XXX}
    \textbf{Symbol}& \textbf{Feature} & \textbf{Datastream}  \\
    \hline
      $F\textsubscript{x}$ & Longitudinal Force	 &  MCS\\
      $F\textsubscript{z}$& Vertical Force	 &MCS \\ 
      $T\textsubscript{y}$& Drive Torque around y-axis	   &MCS\\ 
      $I $& Motor Current	  & JDL\\ 
      $V$ & Voltage 	   &JDL\\ 
      $d\textsubscript{pwm}$&  Dutycycle	   &JDL\\ 
      $w$& Angular Wheel Velocity 	 &JDL \\
      $a\textsubscript{x}$& Acceleration X	  &SDL\\ 
      $a\textsubscript{z}$&  Acceleration Z	   &SDL\\ 
    \end{tabularx}
\end{table}

\begin{table}[h!]
   \centering
    \caption{Optimal feature set for the classification of terrain types by SherpaTT. The set includes the statistical calculation of mean (M) and standard deviation (SD) per terrain patch.\label{fig:optiF}}
    \begin{tabularx}{\columnwidth}{XXX}
    \textbf{Statistical} & \textbf{Feature}  & \textbf{Symbol} \\
    \hline
     M,SD	&  Longitudinal Force	 & F\textsubscript{x} \\ 
     M,SD	&  Drive Torque	around y-axis  & T\textsubscript{y} \\ 
     M,SD	&  Drive Current	 & I \\  
     M,SD	&  Acceleration X	 &  a\textsubscript{x}\\ 
     M,SD	&  Acceleration Z	 & a\textsubscript{z} \\ 
     M,SD	&  Mechanical Power	 & P\textsubscript{m} \\ 
     M,SD	&  Electrical Power	 & P\textsubscript{e} \\ 
     M,SD	&  Friction Coefficient 1	 & \textmu \textsubscript{1} \\ 
     M,SD	&  Friction Coefficient 2 & \textmu \textsubscript{2}\\ 
     M,SD	&  Friction Coefficient 3	 & \textmu \textsubscript{3}\\ 
     M	    &  Angular Wheel Velocity	     &  w      \\ 
     SD    	&  Speed Deviation	 & $\Delta$w\\ 
    \end{tabularx}	
\end{table}

The formulas to calculate the physical parameter are as follows:

  \begin{equation*}
    \begin{aligned}[c]
        & \text{Mechanical Power:} && P\textsubscript{m} = T\textsubscript{y} w \\
        & \text{Electrical Power:} && P\textsubscript{e} = V I d\textsubscript{pwm} \\
        & \text{Friction Coefficient 1:} && \mu \textsubscript{1} = \frac{F\textsubscript{x}}{F\textsubscript{z}} \\
        & \text{Friction Coefficient 2:} && \mu \textsubscript{2} = \frac{T\textsubscript{y}}{R  F\textsubscript{z}} \\ 
        & \text{Friction Coefficient 3:} && \mu \textsubscript{3} = \frac{I}{R F\textsubscript{z}} \\
        & \text{Speed Deviation:} && \Delta w = |w-\overline{w}| 
   \end{aligned}
 \end{equation*}

$R$ represents SherpaTT's wheel radius which corresponds to $0.2085m$.



\subsubsection{Linear Discriminant Analysis}
%copy paste from thesis
Besides speeding up the training and reducing the required amount of data during runtime, the reduction of feature dimensionality can help for data visualization. For this purpose, Linear Discriminant Analysis (LDA) reduces the number of dimensions down to three or two. This makes it possible to plot a high-dimensional data set on a graph and hence visually gain information about patterns. 

To achieve this, LDA identifies the axis that accounts for the largest amount of variance of different class's data. It thereby represents a similar method as the Principle Component Analysis (PCA) with the difference that LDA recognizes the class labels when identifying the variance. As a next step, LDA identifies the axis that lays orthogonal to the first one. Therefore, the second axis accounts for the largest amount of remaining variance. The maximum number of orthogonals, linear discriminants, depends on the number of dimensions within the data set.\cite{kuhr2021}

\section{Implementation}
\todo[inline]{RD: for @RD Review this section}
The classification takes place at a frequency of 100 $Hz$, which corresponds to highest sensor input frequency (joint values). Data streams that run with a lower frequency, provide the same data to several input matrices. At a traverse speed of 0.1 $m/s$, one classification result per traversed 10 $cm$ is retrieved. \todo[inline]{JB: @RD sure? It seems that 1 result per traversed 1mm is achieved.} 
Results must be available at a fast enough pace to allow other onboard components take advantage of the results (e.g. to improve navigation) and to ensure that the classification results correspond to the currently traversed surface. Likewise, the loss of data samples due to full queues on the input of the processing components must be avoided. The diagram in Figure~\ref{fig:overview} presents the implementation approach of the terrain classifier in Rock.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{../figures/OverviewTC2.pdf}
\caption{\label{fig:overview}Overview of the terrain classifier library and Rock integration.}
\end{figure}

\subsection{Training Data}

An essential aspect to the performance of the terrain classifier is the availability of a consistent and large data collection  for training. Data sets for this implementation were acquired from testruns on three different terrain types. One testrun consists of crossing a defined distance forwards or backwards. The conditions that were held the same during all testruns are: (1) a fixed wheel configuration, (2) a surface without inclination, (3) traverse speed of 0.1 $m/s$, (4) straight traverses/ no turns, (5) power generator is running (causes vibrations) and (6) 10 $m$ traverse per testrun. Figure~\ref{fig:TestLocs} shows images of the traversed terrain during the test campaigns. In terms of quantity, the data collection consists of 2200 training samples for each of the 76 features. Regarding data balance, data gathered from the terrain type sand represent 28\% of the overall data and the types concrete and compact sand represent 36\% each. 
When generating a SVM model, one of the data sets of each terrain traverse is used for testing and the others are used for training. This gives a ratio of about 25/75.

\begin{figure}[!htb]
    \begin{subfigure}[t]{0.32\textwidth}
        \includegraphics[width=\textwidth]{../figures/unprepsand.png}
        \caption{Loose Sand}
    \end{subfigure}
    \begin{subfigure}[t]{0.32\textwidth}
        \includegraphics[width=\textwidth]{../figures/compact.png}
        \caption{Compact Sand}
    \end{subfigure}
    \begin{subfigure}[t]{0.32\textwidth}
        \includegraphics[width=\textwidth]{../figures/concrete_v2.png}
        \caption{Concrete}
    \end{subfigure}
 \caption{Shows the three testrun locations in which data sets were acquired. The locations were (a) an area of loose sand, (b) a gravel road with compact sand and (c) a parking lot with concrete paved surface. \label{fig:TestLocs}}
\end{figure}


\section{Evaluation}
\subsection{Offline Classification Performance}
%\todo[inline]{RD: TODO for @LK: Provide the results that were collected when testing offline}

%A complete analysis of performance was not possible, because the traversed terrain during the field tests did not closly match the previously trained terrain classes. Nevertheless, the software shows good classification results, since the type of surface -\emph{wet compact sand}- was close to the two classes mostly identified -\emph{concrete} and \emph{compact sand}.

%The SVM model training software is implemented to enable the use of a variable constellation of logged datasets. Moreover, it can be used to compare both the oÔ¨Ñine and online classification performance. 

The components of a Linear Discriminant Analysis \emph{LDA} are plotted to visualize the achieved data separation. Figure~\ref{fig:offline-class}(b) shows the resulting plot highlighting the decision boundary generated by a Support Vector Kernel (SVC). The areas of different terrain types are highlighted by the corresponding colors. In LDA two Linear Discriminant components, formed from a reduction of the original feature set, are represented on the axes. It is shown that the data of the terrain types can be separated for most of the samples.  

The offline evaluation of the SVM classifier reached an accuracy of 93.97\% depicted in the confusion matrix in Figure~\ref{fig:offline-class}(a). A small portion of the collected data was taken while SherpaTT was not moving. These datapoints for which the wheel speed is zero were sliced out. Based on the sliced data the classification accuracy could be increased by other 2\%. Except the recall for \emph{compact sand} and the precision for \emph{sand} all performances are above 90\%, with an overall accuracy of 93.97\%

\begin{figure}[!htb]
    \centering
    \begin{subfigure}[b]{0.55\textwidth}
        \includegraphics[trim={0 0 0 0},clip,width=\textwidth]{../figures/confusionmatrix_Train.png}
        \caption{Confusion Matrix of the terrain classifier}
    \end{subfigure}
    \begin{subfigure}[b]{0.44\textwidth}
        \includegraphics[width=\textwidth]{../figures/boundary_LDA_prevTesting_all_sand_concrete_compactsand_v2.png}
        \caption{Linear Discriminant Analysis of the dataset}
    \end{subfigure}
    \caption{(a) Performance of the SVM model, the overall accuracy yields 93.97\%. (b) LDA visualization, the areas of different terrain types as classified by the SVM are highlighted by the corresponding colors.}
    \label{fig:offline-class}
\end{figure}
    

\subsection{Onboard tests}

Two main tests were performed to validate the onboard performance of the terrain classifier. During the tests the terrain classifier was executed alongside with the rest of the control and perception software on the rover. The first test took place indoors at the DFKI Robotics Innovation Center premises, depicted in Figure~\ref{fig:sh-tests}. Throughout the trial, the classifier ran at the pursued frequency of 100Hz. Nevertheless, the classification performance of these tests is not representative, because the power generator was not active and the hardest surface was not as firm as concrete. 

The second test took place during the final field trials of the ADE project \cite{ocon2021} in a sand mine in Wulsb√ºttel, Northern Germany.
These tests provided comparable conditions as the ones within the training data set, because the power generator was activated. Several traverses of SherpaTT were logged and checked for consistency to validate the feature calculation. The classification accuracy reached 87\%. A well balanced recall and precision values of the classes were also achieved. 
The underperformance in the field tests can be explained with the encountered surface, which did not match any of the previously examined types closely. Due to rainfalls, the surface consisted of wet compact soil, which sticked to the wheels as shown in Figure~\ref{fig:finaltest}, causing unforseen dynamics.
Nevertheless, the classification resulted in a 87.69\% as \emph{concrete} and a 12.31\% as \emph{compact sand}, complying with the closest types of terrain the classifier was trained with.
The field trials also demonstrated that the terrain classifier can be executed onboard of SherpaTT and that it is able to compute the correct features as well as classify different terrain types successfully while the rover traverses a surface.

\begin{figure}[!t]
    \centering
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[width=\textwidth]{../figures/spacehall.png}
        \caption{Loose Sand Training}
    \end{subfigure}
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[width=\textwidth]{../figures/spacehallconcrete.png}
        \caption{Concrete Training}
    \end{subfigure}
    \caption{Onboard requirement validation of execution frequencies for loose sand (a) and concrete (b).}
    \label{fig:sh-tests}
\end{figure}

\begin{figure}[!h]
    \centering
        \includegraphics[width=0.4\textwidth]{../figures/sandmine_v2.jpg}
    \caption{The analog test site where the classifier was tested.}
    \label{fig:finaltest}
\end{figure}


\subsection{Computational Performance}
The implementation foresees to repeatedly measure the execution time of the code. In the case of this implementation the computation is executed on a single thread. Consequentially, the execution time can be identified measuring the averaged wall time of the code execution. Table~\ref{table:compmeasurments} shows the results of these measurements. The resulting execution time depends on the threading of the operating system, which in this case is the Linux distribution Ubuntu 18.04 LTS. The software runs on a i7 processor with a CPU clock speed of 4.6 GHz. As the averaged execution time of the C++ classification library is 20.3 $ms$, this could lead to the delay of the next data collection step which are done every 10 $ms$ and hence cause the drop of one data sample per second. The drop of one data sample of the one hundred data samples that are strapped every second is assumed to be acceptable.

\begin{table}[htb!]
   \centering
    \caption{Wall time measurements of the methods of the C++ classification library.}
    \begin{tabularx}{\columnwidth}{X|XXX}
        \textbf{Method:} & \multicolumn{3}{X}{Wall Time [$ms$]} \\
        &min.&max.&avg.\\
        \hline
        \hline
        \textbf{calculateFeatures():} & 9&  17.1& 13.2 \\
        \textbf{calculateStat():}     & 6.3 & 13 & 7.1 \\
        \textbf{svmPredict():}        &  0. &  0.001 & 0.0007  \\
        \hline
        \textbf{overall:}             & 15.3 & 30.1 &20.3  \\
    \end{tabularx}	
    \label{table:compmeasurments}
\end{table}


\section{Conclusions}

The presented work explains the implementation of a terrain classifier, which has been deployed and tested onboard of the hybrid locomotion robotic platform SherpaTT.
It has been shown that the SVM classifier provides useful results and can be run onboard along the rest of the software components.

The classification results on the datasets collected along with the training data yield a 93\% of overall accuracy. 
These results have been improved using Deep Learning techniques as shown in \cite{ugenti2021}. 
Thus, in the near future we aim to integrate and test this approach onboard of the system.
During field tests a new type of surface was encountered that did not corresponded to any known class by the classifier. 
Nevertheless the two closest surface types were selected, which we interpret as a robust response.
In the future, this could be improved by combining the approach with an unsupervised technique to automatically identify anomalies and potentially generate new types of surfaces.

% Outlook applications
The applications of the terrain classifier will include contributions to the environment modelling while traversing and the use of the terrain class to adapt various navigation settings.
Besides the final class of terrain, the module computes physical properties of the surface and yields valuable environmental information. 
These features can be used in future missions to predict errors in the localization, e.g. due to different friction coefficients or to generate more realistic contact simulations to further improve the control of the system.
The terrain type has to be taken into account, when setting the costs for the potential paths traversing the corresponding regions. 
For instance, paths over a slope of certain inclination may be traversed if the surface is composed of a material with high friction, but the same task could become very challenging if the friction coefficient on that surface is low. \\


\clearpage

\bibliographystyle{alpha}
\bibliography{sherpatt_terrain_classifier.bib}

\end{document}
